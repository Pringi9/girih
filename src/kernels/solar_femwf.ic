void femwd_solar( const int shape[3], const int xb, const int yb_r, const int zb, const int xe, const int ye_r, const int ze,
    const real_t * restrict coef, real_t * restrict u,
    real_t * restrict v, const real_t * restrict roc2, int t_dim, int b_inc, int e_inc, int NHALO, int tb, int te, stencil_CTX stencil_ctx, int mtid) {

  int tgs_mc = stencil_ctx.thread_group_size/stencil_ctx.th_c;

#pragma omp parallel default(none) shared(tgs_mc, stencil_ctx, shape, roc2, coef, mtid, xb, xe, zb, ze, yb_r, ye_r, tb, te, t_dim, b_inc, e_inc, NHALO, u) \
        num_threads(tgs_mc)
  {
    int i, j, k, t, yb, ye, zi, kt,kb, ke, nwf, th_nwf, tid, gtid, q, r;
    double t_start;

    tid = 0;
    gtid = 0;
#if defined(_OPENMP)
    tid = omp_get_thread_num();
    gtid = tid + mtid * stencil_ctx.thread_group_size;
#endif

    nwf = stencil_ctx.num_wf;
    th_nwf = nwf/tgs_mc;

//      printf("[%d, %d] bs_x:%d  xb:%d  xe:%d  ib_r:%03d  ie_r:%03d  ib:%03d  ie:%03d\n", gtid, tid, bs_x, xb, xe, ib_r, ie_r, ib, ie);
    for(zi=zb; zi<ze; zi+=nwf) { // wavefront loop (Z direction)

      if(ze-zi < nwf){ 
        nwf = ze-zi;
      }

      yb = yb_r;
      ye = ye_r;

      kt = zi;
      for(t=tb; t< te; t++){ // Diamond blocking in time
      // kb = kt; 
      // ke = kt+nwf;

        if(yb<ye){
          for(k=kt; k<kt+nwf; k++){
            if( ((k-NHALO)/th_nwf)%tgs_mc == tid ){
              kb=k;
              ke=kb+1;
              // compute E-field (except at first and last time steps of right-half diamond)
              solar_e_field_kernel_par_comp(shape, xb, yb, kb, xe, ye, ke, coef, u, stencil_ctx);
              // Update block size in Y
            }
          }
        }
        if(t <= t_dim) ye += e_inc; // lower half of the diamond
        else         yb += b_inc; // upper half of the diamond

        t_start = MPI_Wtime();
#pragma omp barrier
        stencil_ctx.t_wait[gtid] += MPI_Wtime() - t_start; 
        if(yb<ye){
          for(k=kt; k<kt+nwf; k++){
            if( ((k-NHALO)/th_nwf)%tgs_mc == tid ){
              kb=k;
              ke=kb+1;
              // compute H-field
              solar_h_field_kernel_par_comp(shape, xb, yb, kb, xe, ye, ke, coef, u, stencil_ctx);
              // Update block size in Y
            }
          }
        }
        if(t < t_dim) yb -= b_inc; // lower half of the diamond
        else         ye -= e_inc; // upper half of the diamond 

        t_start = MPI_Wtime();
#pragma omp barrier
        stencil_ctx.t_wait[gtid] += MPI_Wtime() - t_start;

        kt -= NHALO;
      } // diamond blocking in time (time loop)
    } // wavefront loop
  } // parallel region
}
