void TEMPLATE(femwd,FUNC_NAME)( const int shape[3], const int xb, const int yb_r, const int zb, const int xe, const int ye_r, const int ze,
    const FLOAT_PRECISION * restrict coef, FLOAT_PRECISION * restrict u,
    FLOAT_PRECISION * restrict v, const FLOAT_PRECISION * restrict roc2, int t_dim, int b_inc, int e_inc, int NHALO, stencil_CTX stencil_ctx, int mtid) {

  double t_start;
  int i, j, k, t, zi, kt, yb, ye, tid, not_done, gtid;
  int nny =shape[1];
  int nnx =shape[0];
  unsigned long ln_domain = shape[0]*shape[1]*shape[2];
  int nwf = stencil_ctx.num_wf;
  int time_blk = t_dim*2+1; //temporal block size
  int tgs = stencil_ctx.thread_group_size;
  int th_nwf = nwf/tgs;
  
#pragma omp parallel private(gtid, yb, ye, t, zi, kt, tid, i, j, k, not_done) shared(tgs, nwf, th_nwf, zb, ze, yb_r, ye_r, mtid, xb, xe, time_blk, t_dim, b_inc, e_inc, t_start) num_threads(stencil_ctx.thread_group_size)
  {
    tid = 0;
    gtid = 0;
#if defined(_OPENMP)
    tid = omp_get_thread_num();
    gtid = tid + mtid * tgs;
#endif

    not_done =1;
    zi = zb;
    kt = zb;
    t = 0;
    yb = yb_r;
    ye = ye_r;

    while(not_done) {

//if(t==0)  
//if(tid==1) printf("[%d, %d]t:%d yb_r:%d, ye_r:%d yb:%d ye:%d thb:%d the:%d nwf:%d zi:%d kt:%d \n", 
//                    gtid, tid, t, yb_r, ye_r, yb, ye, thb, the, nwf, zi, kt);

      for(k=kt; k<kt+nwf; k++){
        if ( ((k-NHALO)/th_nwf)%tgs == tid ) {
          if((t)%2 == 1){
            for(j=yb; j<ye; j++) {
#pragma simd
              for(i=xb; i<xe; i++) {U(i,j,k) = coef[0]*V(i,j,k)+coef[1]*(V(i+1,j  ,k  )+V(i-1,j  ,k  ))+coef[1]*(V(i  ,j+1,k  )+V(i  ,j-1,k  ))+coef[1]*(V(i  ,j  ,k+1)+V(i  ,j  ,k-1));}
            }
          }else{
            for(j=yb; j<ye; j++) {
#pragma simd
              for(i=xb; i<xe; i++) {V(i,j,k) = coef[0]*U(i,j,k)+coef[1]*(U(i+1,j  ,k  )+U(i-1,j  ,k  ))+coef[1]*(U(i  ,j+1,k  )+U(i  ,j-1,k  ))+coef[1]*(U(i  ,j  ,k+1)+U(i  ,j  ,k-1));}
            }
          }
        }
      }

      if(t+1 < time_blk){
        if(t< t_dim){ // inverted trapezoid (or lower half of the diamond)
          yb -= b_inc;
          ye += e_inc;
        }else{ // trapezoid  (or upper half of the diamond)
          yb += b_inc;
          ye -= e_inc;
        }
        kt -= NHALO;
        t++;
      } else {
//printf("\n");
        t = 0;
        yb = yb_r;
        ye = ye_r;

        zi+=nwf;
        kt = zi;
        if(zi >= ze) not_done = 0;
      }


      t_start = MPI_Wtime();
#pragma omp barrier
      stencil_ctx.t_wait[gtid] += MPI_Wtime() - t_start;

    } // z loop
  } // parallel region

//printf("\n");
}
