void TEMPLATE(mwd,FUNC_NAME)( const int shape[3], const int xb, const int yb_r, const int zb, const int xe, const int ye_r, const int ze,
    const FLOAT_PRECISION * restrict coef, FLOAT_PRECISION * restrict u,
    FLOAT_PRECISION * restrict v, const FLOAT_PRECISION * restrict roc2, int t_dim, int b_inc, int e_inc, int NHALO, stencil_CTX stencil_ctx, int mtid) {

  double t_start;
  int i, j, k, t, zi, kt, yb, ye, tid, not_done, gtid, thb, the, q, r, ib, ie, ib_r, ie_r;
  int nny =shape[1];
  int nnx =shape[0];
  unsigned long ln_domain = shape[0]*shape[1]*shape[2];
  int nwf = stencil_ctx.num_wf;
  int time_blk = t_dim*2+1; //temporal block size
  int tgs = stencil_ctx.thread_group_size;
  int th_nwf = nwf/tgs;
  int bs_x = stencil_ctx.bs_x;

  // 25-point const. coeff specific
  FLOAT_PRECISION two=2.0;

#pragma omp parallel private(ib_r, ie_r, ib, ie, zi, kt, yb, ye, t, q, r, thb, the, tid, gtid, i, j, k, not_done) shared(bs_x, tgs, nwf, th_nwf, zb, ze, yb_r, ye_r, mtid, xb, xe, time_blk, t_dim, b_inc, e_inc, t_start) num_threads(stencil_ctx.thread_group_size)
  {
    

    tid = 0;
    gtid = 0;
#if defined(_OPENMP)
    tid = omp_get_thread_num();
    gtid = tid + mtid * tgs;
#endif


    ib_r = xb;
    while(ib_r < xe){ // blocking in X
      ie_r = (ib_r+bs_x)<(xe)?(ib_r+bs_x):(xe);
      ib = ib_r;
      ie = ie_r;

      not_done = 1;
      zi = zb;
      kt = zb;
      t = 0;
      yb = yb_r;
      ye = ye_r;
      thb = th_nwf*tid;
      the = th_nwf*(tid+1);
      while(not_done) { // wavefront loop (Z direction)

  //if(t==0)  
  //if(tid==1) 
//  printf("[%d, %d]ib_r:%d ie_r:%d ib:%d ie:%d bs_x:%d t:%d yb_r:%d, ye_r:%d yb:%d ye:%d thb:%d the:%d nwf:%d zi:%d kt:%d \n", 
//                      gtid, tid, ib_r, ie_r, ib, ie, bs_x, t, yb_r, ye_r, yb, ye, thb, the, nwf, zi, kt);

          if((t)%2 == 1){
            for(k=kt+thb; k<kt+the; k++){
              for(j=yb; j<ye; j++) {
  #pragma simd
                for(i=ib; i<ie; i++) {
                  FUNC_BODY(U,V)
                }
              }
            }

          }else{
            for(k=kt+thb; k<kt+the; k++){
              for(j=yb; j<ye; j++) {
  #pragma simd
                for(i=ib; i<ie; i++) {
                  FUNC_BODY(V,U)
                }
              }
            }
          }


          if(t+1 < time_blk){ // update size in X and Y during diamond update
            // Update block size in Y
            if(t< t_dim){ // lower half of the diamond
              yb -= b_inc;
              ye += e_inc;
            }else{ // upper half of the diamond
              yb += b_inc;
              ye -= e_inc;
            }
            kt -= NHALO;
            t++;

            // Update block size in X
            if (ib != xb) ib-=NHALO;
            if (ie != xe) ie-=NHALO;

          } else { // reset counters after diamond update
  //printf("\n");
            t = 0;
            yb = yb_r;
            ye = ye_r;
 
            ib = ib_r;
            ie = ie_r;

            zi+=nwf;
            kt = zi;
            if(zi >= ze) not_done = 0;
          }

        // reassign the wavefronts to cores if fraction of multi-frontlines remains
        if( ((ze-zi) < nwf) & (t == 0)){ 
          q = (int)((ze-zi)/tgs);
          r = (ze-zi)%tgs;
          if(tid < r) {
            thb = tid * (q+1);
            the = thb + (q+1);
          }else {
            thb = r * (q+1) + (tid - r) * q;
            the =thb + q;
          }
  //if(not_done == 1) printf("[%d]  q:%d r:%d thb:%d the:%d rem:%d\n", tid, q, r, thb, the, ze-zi);
        }

        t_start = MPI_Wtime();
  #pragma omp barrier
        stencil_ctx.t_wait[gtid] += MPI_Wtime() - t_start;

      } // z loop (wavefront)

      // move to next block in X
      ib_r += bs_x;
    } // Blocking in X loop
    
  } // parallel region

//printf("\n");
}
