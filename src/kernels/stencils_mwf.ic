void TEMPLATE(mwd,FUNC_NAME)( const int shape[3], const int xb, const int yb_r, const int zb, const int xe, const int ye_r, const int ze,
    const FLOAT_PRECISION * restrict coef, FLOAT_PRECISION * restrict u,
    FLOAT_PRECISION * restrict v, const FLOAT_PRECISION * restrict roc2, int t_dim, int b_inc, int e_inc, int NHALO, stencil_CTX stencil_ctx, int mtid) {

  int i, j, k, t, yb, ye, zi, kt, ib, ie;
  int ib_r, ie_r, bs_x, thb, the, nwf, tid, gtid, th_nwf, tgs, q, r;
  int nny =shape[1];
  int nnx =shape[0];
  unsigned long  ln_domain = shape[0]*shape[1]*shape[2];
  int time_blk = t_dim*2+1; //temporal block size
  double t_start;

  // 25-point const. coeff specific
  FLOAT_PRECISION two=2.0;
  
  bs_x = stencil_ctx.bs_x;
  tgs = stencil_ctx.thread_group_size;
  nwf = stencil_ctx.num_wf;
  th_nwf = nwf/tgs;


#pragma omp parallel default(none) shared(ln_domain, two, u, v, roc2, coef, nnx, nny, tgs, nwf, th_nwf, mtid, xb, xe, bs_x, zb, ze, yb_r, ye_r, time_blk, t_dim, b_inc, e_inc, NHALO) \
        private(tid, gtid, ib_r, ie_r, zi, yb, ye, ib, ie, kt, t, k, j, i, thb, the, q, r, t_start) \
        num_threads(stencil_ctx.thread_group_size)

//private(ib_r, ie_r, ib, ie, zi, kt, yb, ye, t, q, r, thb, the, tid, gtid, i, j, k, not_done) shared(bs_x, tgs, nwf, th_nwf, zb, ze, yb_r, ye_r, mtid, xb, xe, time_blk, t_dim, b_inc, e_inc, t_start) num_threads(stencil_ctx.thread_group_size)
  {
    tid = 0;
    gtid = 0;
#if defined(_OPENMP)
    tid = omp_get_thread_num();
    gtid = tid + mtid * tgs;
#endif

    thb = th_nwf*tid;
    the = th_nwf*(tid+1);

    for(ib_r=xb; ib_r<xe; ib_r+=bs_x) { // blocking in X
      ie_r = (ib_r+bs_x)<(xe)?(ib_r+bs_x):(xe);
      //printf("bs_x:%d  xb:%d  xe:%d  ib:%d  ie:%d\n", bs_x, xb, xe, ib, ie);
      for(zi=zb; zi<ze; zi+=nwf) { // wavefront loop (Z direction)

        if(ze-zi < nwf){ 
          q = (int)((ze-zi)/tgs);
          r = (ze-zi)%tgs;
          if(tid < r) {
            thb = tid * (q+1);
            the = thb + (q+1);
          }else {
            thb = r * (q+1) + (tid - r) * q;
            the =thb + q;
          }
        }

        yb = yb_r;
        ye = ye_r;

        ib = ib_r;
        ie = ie_r;

        kt = zi;
        for(t=0; t< time_blk; t++){ // Diamond blocking in time

          if((t)%2 == 1){
            for(k=kt+thb; k<kt+the; k++){
              for(j=yb; j<ye; j++) {
    #pragma simd
                for(i=ib; i<ie; i++) {
                  FUNC_BODY(U,V)
                }
              }
            }

          }else{
            for(k=kt+thb; k<kt+the; k++){
              for(j=yb; j<ye; j++) {
    #pragma simd
                for(i=ib; i<ie; i++) {
                  FUNC_BODY(V,U)
                }
              }
            }

          } // end diamond blocking in time

          // Update block size in Y
          if(t< t_dim){ // lower half of the diamond
            yb -= b_inc;
            ye += e_inc;
          }else{ // upper half of the diamond
            yb += b_inc;
            ye -= e_inc;
          }

          // Update block size in X
          if (ib != xb) ib-=NHALO; 
          if (ie != xe) ie-=NHALO;

          kt -= NHALO;

          t_start = MPI_Wtime();
#pragma omp barrier
          stencil_ctx.t_wait[gtid] += MPI_Wtime() - t_start;

        } // diamond blocking in time (time loop)
      } // wavefront loop
    } // blocking in x
  } // parallel region
}
